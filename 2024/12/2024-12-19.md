 # 2024-12-18

## 자료구조 공부 내용

### 큐
- 먼저 들어온 데이터가 먼저 나가는 선입선출(FIFO)
- 큐 활용 예시 : 대기열, 비행기들, 데이터 패킷 모델링, 버퍼, 시뮬레이션의 대기행렬
  - 데이터를 생산하는 생산자 프로세스와 소비하는 소비자 프로세스가 있으며 사이에 큐로 구성되는 버퍼가 있다.
  - 컴퓨터의 cpu와 주변기기들은 속도 차이가 있기 때문에 효율적 사용 위하여.
- 삽입연산 enqueue, 삭제연산 dequeue
- 두개의 변수 사용 : 삽입과 관련된 변수 rear, 삭제와 관련된 변수 front
- **선형 큐**
  - front, rear 의 초기값은 -1
  - 데이터 증가시 rear 하나 증가 후 그 위치에 저장
  - 데이터 삭제시 front 하나 증가 후 그 위치에 있는 데이터 삭제  

### **선형 큐 vs 원형 큐**
- 선형 큐는 front 와 rear의 값이 증가만 하여 앞부분을 재활용 하기 어렵다. 주기적으로 앞부분으로 이동시키면 O(n)의 시간이 들어 비효율적이다.
- 배열의 끝에 도달하면 다음에 증가되는 값은 0이 되도록 하여 원형 큐를 만든다.

- **원형 큐**
  - front, rear 의 초기값은 0
  - front는 항상 큐의 첫번째 요소의 하나 앞을, rear는 맨 마지막 요소를 가리킨다.
  - 원형 큐 에서는 포화상태와 공백상태를 구별하기 위해 하나의 자리는 항상 비워둔다.
  - front 와 rear 값이 같으면 공백상태, front가 rear보다 한칸 앞에 있으면 포화상태
  - 나머지 연산자 % 를 사용하여 값이 MAX_SIZE -1 값에서 하나 증가해서 0으로 가야되면 MAX_SIZE로 나눈 나머지 값을 구하여 0으로 되도록 만든다.
  - 원형 큐 에서는 front 와 rear가 역전되는 경우가 있다.


### 덱
- double ended queue의 줄임말
- 큐의 front, rear에서 모두 삽입, 삭제가 가능한 큐를 덱이라고 한다.
- ADT DEQUE = 객체 : n개의 element형의 요소들의 순서있는 모임 / 연산 : 생성 초기화 공백검사 포화검사 앞추가 뒤추가 앞반환 뒤반환
- 원형큐를 확장하면 손쉽게 덱 구현 가능
- 덱에 새롭게 추가된 연산은 delete_rear(), add_front(), get_rear() 이다._
  - delete_rear()와 add_front()에서는 반대 방향 회전이 필요하다. (-1 연산) 이때 음수가 되면 MAX_SIZE를 더해주어야 한다.
  - front <- (front-1) + MAX_QUEUE_SIZE % MAX_QUEUE_SIZE;
  - rear <- (rear -1) + MAX_QUEUE_SIZE % MAX_QUEUE_SIZE;


