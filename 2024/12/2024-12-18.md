 # 2024-12-18

## 자료구조 공부 내용

### 희소행렬
- 대부분의 요소가 0인 행렬
1. 2차원 배열 사용  
  - 장점 : 간단하게 행렬의 연산들을 구현 (전치연산 쉬움)
  - 단점 : 많은 항이 0인 경우 많은 메모리 공간 낭비
2. 0이 아닌 노드값만 (행, 열, 값)으로 표현
  - 행렬 하나의 요소를 (row, col, value)로 표현 후 element 구조체로 정의
  - 0이 아닌 요소 여러개가 있을 수 있으므로 element 배열이 필요.
  ```c
  typedef struct {
    int row; // 행 좌표값
    int col; // 열 좌표값
    int value; // 값
  } element;
  typedef struct SparseMatrix{
    element[data[MAX_SIZE]];
    int rows; // 몇 행인지 행의 수
    int cols; // 몇 열인지 열의 수
    int terms; // 값이 총 몇개 있는지 항의 수
  } SparseMatrix;
  ```

### 포인터
- 다른 변수의 주소를 가지고 있는 변수
  -  모든 변수는 메모리 공간에 저장되고 메모리의 각 바이트에는 주소가 매겨져 있다.
- 배열의 이름 <= 배열의 시작위치를 가르키는 포인터

**문제** 두 함수 정의의 차이를 설명하시오.

  ```c
  void sub1(Point *p){ ... }

  void sub2(Point **pp){ ... }
  ```

**해설**
p는 구조체를 가리키는 포인터, pp는 구조체의 포인터의 주소를 가리키는 포인터이다.   
p는 구조체의 내용을 변경, 멤버에 접근 가능하고, pp는 구조체 포인터가 가르키는 대상을 변경 가능하다.

### 동적 메모리 할당
- 필요한 만큼의 메모리를 운영체제로부터 할당 받아서 사용하고, 사용이 끝나면 시스템에 메모리를 반납하는 기능

- **힙** : 동적 메모리가 할당되는 공간 , 운영체제가 사용되지 않는 메모리공간을 모아놓은 곳.

  ```c
  int *p;
  p = (int *)malloc(sizeof(int)); // 동적 메모리 할당
  *p = 1000; // 동적 메모리 사용
  free(p); // 동적 메모리 반납
  ```

- malloc 함수는 동적 메모리 블럭의 시작 주소를 반환한다. 기본형은 void * 이므로 형변환을 해줘야 한다.
 - malloc 함수는 시스템의 메모리가 부족해서 할당 불가능하면 NULL을 반환하므로 반환값을 항상 NULL인지 검사해야 한다.


### 구조체와 포인터
- 구조체에 대해 포인터를 선언하고 포인터를 통해 구조체 멤버에 접근 가능.
- (*p).i 보다 p->i  라고 쓰는 것이 편리.
- 구조체 자체를 전달하는 경우, 복사되어 전달되기 때문에, 구조체 포인터를 매개변수로 전달한다.

**문제** 다음 프로그램의 오류를 모두 지적하시오.
  ```c
  int main(void){
    double *p1;
    p1 = (int *)malloc(double);
    p1 = 23.92;
  }
  ```

**해설**
1. p1은 double형인데 int 로 형변환을 해주어서 오류 -> (double*) 로 수정
2. malloc 안의 값은 형의 크기 -> sizeof(double)로 수정
3. malloc 반환값이 NULL인지(할당 가능한 메모리 체크) 체크해야한다. -> if(p1 == NULL) 체크  
4. p1 은 주소값이다 . p1이 가리키는 값을 변경하려면 *p1을 사용해야한다.   
5. 동적 메모리를 반납해야한다. -> free(p1)   

- char : 1byte
- float : 4byte
- double : 8byte
- int : 4byte

  ```c
  strcpy(s->name, "Park");
  s->age = 20;
  ```
**해설**
그냥 s->name = "PARK" 이라고 하면 값 변경이 불가능하다. park은 문자 배열이기 때문에 park의 주소를 할당하기 때문에 (주소값이기 때문에)    
strcpy 함수를 사용해서 복사 해주어야 한다.

### 스택
- 스택은 자료의 출력순서가 입력순서의 역순으로 이루어져야 할 경우 사용된다.
- LIFO(후입선출)
- stack top, stack bottom, 요소 element(스택에 저장되는 것)   


**스택이 사용될 때**
  - **함수 호출** : 함수는 실행이 끝나면 자신을 호출한 함수로 되돌아가야 한다. (스택은 복귀주소 기억하는데 사용)
    - 시스템 스택에 활성레코드 생성 -> 매개변수, 지역변수, 프로그램카운터, 복귀주소
  - **괄호 검사**
    1. 왼쪽 괄호의 개수와 오른쪽 괄호의 개수 같아야한다.
    2. 같은 종류의 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야한다.
    3. 서로 다른 종류의 왼쪽 괄호와 오른쪽 괄호 쌍은 서로 교차하면 안된다.
  - **후위 표기 수식의 계산**
    - 컴파일러가 후위표기를 선호하는 이유 : 괄호 필요 x, 우선순위 생각 x, 읽으면서 바로 계산 가능
    - 계산 알고리즘 : 피연산자면 스택에 push, 연산자면 스택에서 두개를 pop하여 계산 값을 push 한다
  - **중위표기수식을 후위표기수식으로 변환**
    - 알고리즘 : 피연산자면 출력, 연산자면 스택에 push, but 스택 안에 있는 연산자의 우선순위가 더 크거나 같다면 pop해서 출력 후 저장
    - 왼쪽괄호는 무조건 스택에 push (젤 우선순위 낮다고 취급), 오른쪽 괄호 만나면 왼쪽괄호 까지 쌓인 모든 연산자 pop.
  - **미로문제** : 시행착오 방법
    - 알고리즘 : 이동 가능한 칸을 위, 아래, 왼쪽, 오른쪽의 순서로 스택에 저장하고 스택의 맨 위의 위치를 꺼내 이동
    - 이미 갔던 곳은 .으로 표시하여 가지 않도록하여 무한루프 방지, 위치는 (행,열)로 표시. 
    - 2차원 배열로 미로를 표시, 0이면 갈 수 있는길, 1이면 갈 수 없는길, (행,열)을 구조체로 만든다.


**추상 자료형 스택**
  - 객체 : 0개 이상의 원소를 가지는 선형 리스트 /  연산 : 생성, 추가, 반환


- 스택 구현 방법
  1. **배열**을 이용 : 구현 간단, 성능 우수 , 스택 크기가 고정
  2. **연결 리스트**를 이용 : 구현 복잡, 스택 크기 필요에 따라 가변 적용

**스택의 구현**
  - is_empty(), is_full(), push(), pop()

- **스택 저장값이 복잡할때** 스택에 저장되어야 하는 값이 정수나 문자가 아니고 복잡한 구조라면 스택에 **구조체**를 저장하면 된다.
  - 구조체로 스택에 저장되는 데이터를 정의한 뒤 , 구조체의 포인터를 함수의 매개변수로 전달

- **여러개의 스택 필요할때** stack 배열과 top 변수를 전역변수에 선언하면 하나의 프로그램에서 여러개의 스택을 동시에 사용하기 어렵다.
  - top과 stack 배열을 하나의 구조체로 결합, 이 구조체의 포인터를 함수로 전달 (StackType이라는 새로운 구조체 생성) -> 여러개의 스택 생성 가능

- **스택을 동적 메모리 할당으로 생성할때** 
  - main문에서 StackType *s; s=(StackType *)malloc(sizeof(StackType)); free(s);

- **컴파일 시간에 크기 결정 하지 않고, 실행 시간에 메모리를 할당 받고 싶을 때**
  - element data[MAX_SIZE] -> element *data; // stack배열을 바로 할당했던 것에서 포인터로 정의 한 뒤, 
  - 스택 생성함수 init_stack() 을 만든 뒤, s->data = (element *)malloc(s->capacity*sizeof(element)); 생성함수 만들어서 실행 하고 생성하도록 한다.
  - 이때 push함수에 is_full()이 참 이라면 capacity값을 *2 후, s->data = (element *)realloc(s->data, s->capacity*sizeof(element));
  - 를 통해 실행시간에 메모리를 유동적으로 할당 받을 수 있다.

- malloc(크기) : 새로운 메모리 공간 동적 할당, 단순히 지정된 크기 할당
- realloc(이전에 할당된 메모리 가르키는 포인터, 새로운 크기) : 이미 할당된 메모리의 크기 조절, 기존 데이터 보존 후 새 메모리영역으로 복사.


- 문자형 숫자를 실제 정수로 변환 하려면 ASCII 값 이용하여 int value = char ch - '0';
  - 만약 ch 가 '2'이라면 '2'는 아스키 값으로 50 이므로 '0'의 아스키 값인 48과 계산 되어 2가 된다.